import java_cup.runtime.Symbol;






%%
%class Lexer

%implements java_cup.runtime.Scanner
%function next_token
%type java_cup.runtime.Symbol

%eofval{
	return new Symbol(sym.EOF, null);
%eofval}




DIGIT=[0-9]	




NUMBER=({DIGIT})+([.]({DIGIT})+)?
ALPHA=[a-zA-z]
ALPHA_NUMERIC={ALPHA}|{DIGIT}




WFF=wff 
ACTIVATE=activate
WITHSOME=withsome
WITHALL=withall

ACTIVATEASSERT=activate!
ADDTOCONTEXT=add-to-context
ASK=ask
ASKIFNOT=askifnot
ASKWH=askwh
ASKWHNOT=askwhnot
BELIFESABOUT=beliefs-about
AFTERBR=auto|manual

BRMODE=br-mode
BRCMD={BRMODE}({AFTERBR})?

BRTIEMODE=br-tie-mode
BRTIECMD={BRTIEMODE}({AFTERBR})?

CLEARINFER=clear-infer
CLEARKB=clearkb
COPYRIGHT=copyright

DEFINEFRAME=define-frame
DEFINEPATH=define-path
DEMO=demo
DESCRIBECONTEXT=describe-context
DESCRIBETERMS=describe-terms

EXPERT=expert

LISP=lisp
LIST-ASSERTED-WFFS=list-asserted-wffs
LISTCONTEXTS=list-contexts
LISTTERMS=list-terms
LISTWFFS=list-wffs
LOAD=load


NORMAL=normal

PERFORM=perform

REMOVEFROMCONTEXT=remove-from-context

SETCONTEXT=set-context
SETDEFAULTCONTEXT=set-default-context

SETMODE1=set-mode-1
SETMODE2=set-mode-2
SETMODE3=set-mode-3

SETORDERH=explicit|fluent|null-order|source
SETORDER=set-order
SETORDERCMD={SETORDER}({SETORDERH})?

SHOW=show
TRACE=trace
UNDEFINEPATH=undefine-path
UNLABELED=unlabeled
UNTRACE=untrace

AND=and
OR=or
NAND=nand
NOR=nor
XOR=xor
IFF=iff


ANDOR=andor
THRESH=thresh
ALL=all
NEXISTS=nexists




IDENTIFIER=({ALPHA})+






WHITE_SPACE=([\ \n\r\t\f\b])+




%%
<YYINITIAL> {WHITE_SPACE} { }




<YYINITIAL> {WFF} { 
	return new Symbol(sym.WF, yytext());
}

<YYINITIAL> {AND} { 
	return new Symbol(sym.AND, yytext());
}

<YYINITIAL> {OR} { 
	return new Symbol(sym.OR, yytext());
}



<YYINITIAL> "<=>" { 
	return new Symbol(sym.DOUBLEIMPLICATION, yytext());
}

<YYINITIAL> "~" { 
	return new Symbol(sym.NOT, yytext());
}

<YYINITIAL> {ANDOR} { 
	return new Symbol(sym.ANDOR, yytext());
}
<YYINITIAL> {THRESH} { 
	return new Symbol(sym.THRESH, yytext());
}

<YYINITIAL> {NEXISTS} { 
	return new Symbol(sym.NEXISTS, yytext());
}

<YYINITIAL> {ALL} { 
	return new Symbol(sym.ALL, yytext());
}


<YYINITIAL> {NUMBER} { 
	return new Symbol(sym.NM, ""+Integer.parseInt(yytext()));
}


<YYINITIAL> {WITHSOME} { 
	return new Symbol(sym.WITHSOME, yytext());
}

<YYINITIAL> {WITHALL} { 
	return new Symbol(sym.WITHALL, yytext());
}


<YYINITIAL> {IDENTIFIER} { 
	return new Symbol(sym.ID, yytext());
}




<YYINITIAL> "?" { 
	return new Symbol(sym.QM, yytext());
}

<YYINITIAL> "," { 
	return new Symbol(sym.COMA, yytext());
}


<YYINITIAL> "." { 
	return new Symbol(sym.DT, yytext());
}



<YYINITIAL> "=>" { 
	return new Symbol(sym.ARROW, yytext());
}


<YYINITIAL> "&=>" { 
	return new Symbol(sym.ANDENTAIL, yytext());
}

<YYINITIAL> "v=>" { 
	return new Symbol(sym.ORENTAIL, yytext());
}

<YYINITIAL> {NUMBER}"=>" { 
	return new Symbol(sym.II, yytext());
}


<YYINITIAL> "{" { 
	return new Symbol(sym.RCURLY, yytext());
}
<YYINITIAL> "}" { 
	return new Symbol(sym.LCURLY, yytext());
}






<YYINITIAL> {DIGIT}+"=>" { 
	return new Symbol(sym.NE, yytext());
}








<YYINITIAL> ":" { 
	return new Symbol(sym.CL, yytext());
}





<YYINITIAL> "(" { 
	return new Symbol(sym.LP, yytext());
}

<YYINITIAL> ")" { 
	return new Symbol(sym.RP, yytext());
}	
<YYINITIAL> "!" { 
	return new Symbol(sym.EM, yytext());
}




<YYINITIAL> . {
	return new Symbol(sym.error, "Error!");
}


